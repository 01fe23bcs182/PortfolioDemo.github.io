<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Data Structures and Algorithms Summary</title>
    <style>
        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            line-height: 1.8;
            background-color: #030303;
            color: #212529;
            margin: 0;
            padding: 20px;
        }
       
        h1, h2, h3 {
            color: #007bff;
        }
        h1 {
            text-align: center;
            text-transform: uppercase;
            margin-bottom: 20px;
            color: #fefeff;
            background-color: #039311;
            padding: 10px;
            border-radius: 5px;
        }
        h2 {
            margin-top: 30px;
            border-bottom: 2px solid #0f0f10;
            padding: 10px;
            background-color: #30da2d;
            border-radius: 4px;
            color: #020202;
        }
        h3 {
            margin-top: 20px;
            font-style: italic;
        }
        ul {
            list-style-type: disc;
            margin: 15px 20px;
        }
        li {
            margin-bottom: 8px;
        }
        code {
            background-color: #dfe6ed;
            padding: 2px 4px;
            border-radius: 4px;
            font-size: 0.95em;
        }
        p {
            margin: 15px 0;
        }
        strong {
            color: #343a40;
        }
        .container {
            max-width: 800px;
            margin: 0 auto;
            padding: 20px;
            background-color: #d0f9bd;
            border-radius: 8px;
            box-shadow: 0 2px 4px rgba(0, 0, 0, 0.1);
        }
        .note {
            font-size: 0.9em;
            background-color: #f8f9fa;
            border-left: 4px solid #6da4de;
            padding: 10px;
            margin-top: 10px;
        }
        footer {
            text-align: center;
            margin-top: 40px;
            font-size: 0.9em;
            color: #6a7077;
        }
    .navbar {
    position: sticky;
    top: 0;
    background-color:  #0c540e;
    width: 100%;
    z-index: 1000;
    padding: 0.5rem 1rem;
    box-shadow: 0px 4px 6px rgba(0, 0, 0, 0.1);
    display: flex;
    border-radius: 10px;
    justify-content: center;
    justify-content: space-between;
  }

 
  
  .nav-list {
    list-style: none;
    display: flex;
    justify-content: space-around;
    align-content: center;
    margin: 0;
    padding: 0;
    
  }
  
  .nav-list li {
    margin: 0;
    color: #866545;
  }
  
  .nav-list a {
    text-decoration: none;
    color: #FB5235;
    align-content: center;
    padding: 1rem 1rem;
    transition: background-color 0.3s ease;
  }
  
  .nav-list a:hover {
    transform: scale(1.02);  
    background-color: #2fef2c;
   
    box-shadow: 0 6px 10px rgba(0, 0, 0, 0.15);  
    transition: transform 0.2s, box-shadow 0.2s;
    border-radius: 4px;
  }
  
  .content {
    padding: 2rem;
    font-size: 1.2rem;
    line-height: 1.6;
  }
    </style>
</head>
<body>
    <nav class="navbar">
        <ul class="nav-list">
            <li><a style="color:rgb(255, 255, 255)"  href="/PortfolioDemo.github.io/blocks/home/home.html">Home</a></li>
            <li><a style="color:rgb(255, 255, 255)"  href="/PortfolioDemo.github.io/index.html">PROJECT OVERVIEW</a></li>
            <li><a  style="color:rgb(253, 251, 251)" href="/PortfolioDemo.github.io/blocks/learningref/teamlearning.html">Learning Reflections</a></li>
        </ul>
    </nav>
  <section>
    
        <h1>Data Structures and Algorithms </h1>
        <div class="container">
        <h2>1. What are the kinds of problems we see in nature?</h2>
        <ul>
            <li><strong>Iteration:</strong> Problems that require repeating a process multiple times, like a cycle or pattern. For example, a plant growing in a specific direction with each cycle. </li>
            <li><strong>Recursion:</strong>Problems where a process repeats itself in smaller versions of the same problem. For instance, the branching pattern of trees, where each branch grows into smaller branches  </li>
            <li><strong>Backtracking:</strong>Problems that involve exploring all possible solutions and undoing steps when a path doesn’t work. An example is finding the shortest path in a maze or exploring animal migration routes  </li>
        </ul>
    </div>
    
    <div class="container">
        <h2>2. What is space and time efficiency? Why are they important? Explain the different classes of problems and orders of growth</h2>
        <ul>
            <li><strong>Space Efficiency:</strong>refers to how much memory or storage an algorithm uses.</li>
            <li><strong>Time Efficiency:</strong>  Refers to how fast an algorithm performs, measured by the time it takes to run.</li>
        </ul>
    <p>Algorithm complexity is measured using Big-O notation:</p>
        <ul>
            <li><strong>O(1):</strong> Constant time (fastest).</li>
            <li><strong>O(log n):</strong> Logarithmic growth.</li>
            <li><strong>O(n):</strong> Linear growth.</li>
            <li><strong>O(n²):</strong> Quadratic growth (slower).</li>
        </ul>      
    </div>

    <div class="container">
        <h2>3. Take away from different design principles from chapter 2</h2>
      <p>Key design principles include:</p>
        <ul>
            <li><strong>Divide and Conquer:</strong> Break problems into smaller, manageable subproblems (e.g., MergeSort, QuickSort).</li>
            <li><strong>Greedy Algorithms:</strong> Make the best local choice at each step (e.g., Kruskal’s MST algorithm).</li>
            <li><strong>Dynamic Programming:</strong> Store solutions to overlapping subproblems (e.g., Fibonacci numbers, longest common subsequence).</li>
        </ul>
        <p>These principles improve problem-solving efficiency and applicability to real-world scenarios.</p>


    </div>

    <div class="container">
        <h2>4. The hierarchical data and how different tree data structures solve and optimize over the problem scenarios (tree, bst, avl, 2-3, red-black, heap, trie)</h2>
        <h3>Ans:</h3>
        <p>Tree data structures organize hierarchical data efficiently. Examples include:</p>
        <ul>
            <li><strong>Binary Search Trees (BST):</strong> Efficient for searching and sorting.</li>
            <li><strong>AVL Trees:</strong> Self-balancing BST for maintaining logarithmic height.</li>
            <li><strong>Red-Black Trees:</strong> Ensure balanced trees for faster insertions/deletions.</li>
            <li><strong>Heaps:</strong> Used for priority queues.</li>
            <li><strong>Tries:</strong> Efficient for prefix-based searching (e.g., autocomplete).</li>
        </ul>
        <p>These structures optimize memory usage and reduce time complexity.</p>

    </div>

    <div class="container">
        <h2>5. The need for array query algorithms and their implications. Their applications and principles need to be discussed</h2>
        <h3>Ans:</h3>
       <p>Array query algorithms are needed to efficiently process and retrieve data from large arrays. These algorithms help in answering queries such as finding sums, minimum/maximum values, or performing updates on arrays</p>
        <ul>
            <li>Implications: They improve performance by reducing the time complexity for repeated queries, making operations more efficient in large datasets</li>
            <li>Without efficient array query algorithms, operations like searching or updating data in an array could take too long.</li>
        </ul>
        <p>Applications of array query algorithms include efficiently handling range queries (like sum, min, max), dynamic updates, and search operations in large datasets, such as in databases, real-time systems, and computational problems in fields like gaming, machine learning, and network analysis.</p>

    </div>

    <div class="container">
        <h2>6. Differentiate between tree and graphs and their traversals. The applications of each</h2>
        <h3>Ans:</h3>
        <p>Trees and graphs differ fundamentally:</p>
        <ul>
            <li><strong>Trees:</strong> Acyclic, hierarchical structures (e.g., family trees).</li>
            <li><strong>Graphs:</strong> Generalized structures allowing cycles (e.g., road networks).</li>
        </ul>
        <p>Traversals include:</p>
        <ul>
            <li><strong>Tree Traversals:</strong> Preorder, Inorder, Postorder.</li>
            <li><strong>Graph Traversals:</strong> BFS and DFS.</li>
        </ul>
        <p>Applications range from pathfinding to data organization.</p>

    </div>
     <div class="container">
        <h2>7.Deliberate on sorting and searching algorithms, the technique behind each and their connection to the real world</h2>
         <h3>Ans:</h3>
          <p>Sorting algorithms (e.g., QuickSort, MergeSort) and searching algorithms (e.g., Binary Search) are vital for:</p>
        <ul>
            <li>Organizing large datasets.</li>
            <li>Improving data retrieval times in databases and search engines.</li>
        </ul>

       </div>
       <div class="container">
        <h2>8..Discuss the importance of graph algorithms with respect to spanning trees and shortest path.</h2>
         <h3>Ans:</h3>
          <p>Graph algorithms like Dijkstra's and Kruskal's are essential for:</p>
        <ul>
            <li>Spanning Trees: Ensure all nodes are connected with the minimum number of edges, useful for efficient network design</li>
            <li>Shortest Paths: Find the quickest route between nodes, reducing travel time or resource usage.</li>
        </ul>
        <p>Application: Used in GPS navigation to find the fastest route between locations. </p>
     </div>
       <div class="container">
       <h2>9.Discuss about the different studied algorithm design techniques.</h2>
        <h3>Ans:</h3>
     <p>Studied algorithm design techniques include:</p>
        <ul>
            <li><strong>Divide and Conquer:</strong> Break problems into smaller pieces (e.g., MergeSort).</li>
            <li><strong>Dynamic Programming:</strong> Solve overlapping subproblems using memoization (e.g., knapsack problem).</li>
            <li><strong>Greedy Algorithms:</strong> Make locally optimal choices to achieve a global optimum (e.g., Huffman coding).</li>
        </ul>
        <p>These techniques address diverse real-world challenges efficiently.</p>
    </div>
  </section>
  <button onclick="window.history.back();" style="background-color: #0bb12f; color: rgb(241, 233, 233); border: none; padding: 10px 20px; font-size: 1rem; cursor: pointer; border-radius: 5px; margin-bottom: 20px;">Back</button>
</body> 
</html>
